{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"http4s-jdk-http-client"},{"location":"/index.html#http4s-jdk-http-client","text":"","title":"http4s-jdk-http-client"},{"location":"/index.html#http-client","text":"http4s-jdk-http-client contains a http4s-client implementation based on the java.net.http.HttpClient introduced in Java 11.","title":"HTTP client"},{"location":"/index.html#installation","text":"To use http4s-jdk-http-client in an existing SBT project, add the following dependency to your build.sbt:\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-jdk-http-client\" % \"0.3.1+58-c1106a87-SNAPSHOT\"\n)","title":"Installation"},{"location":"/index.html#compatibility","text":"Requires Java 11 or greater Built for Scala 2.12 and 2.13 Works with http4s-client-0.21.8\nTLS 1.3 on Java 11 On Java 11, TLS 1.3 is disabled by default (when using JdkHttpClient.simple). This is a workaround for a spurious bug, see #200.","title":"Compatibility"},{"location":"/index.html#creating-the-client","text":"","title":"Creating the client"},{"location":"/index.html#simple","text":"A default JDK HTTP client can be created with a call to simple for any ConcurrentEffect type, such as cats.effect.IO:\nimport cats.effect.IO\nimport org.http4s.client.Client\nimport org.http4s.client.jdkhttpclient.JdkHttpClient\n\n// A `Timer` and `ContextShift` are necessary for a `ConcurrentEffect[IO]`.\n// They come for free when you use `cats.effect.IOApp`:\nimport cats.effect.{ContextShift, Timer}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimplicit val timer: cats.effect.Timer[IO] = IO.timer(global)\nimplicit val cs: cats.effect.ContextShift[IO] = IO.contextShift(global)\n\nval client: IO[Client[IO]] = JdkHttpClient.simple[IO]","title":"Simple"},{"location":"/index.html#custom-clients","text":"A JDK HTTP client can be passed to JdkHttpClient.apply for use as an http4s-client backend. It is a good idea to create the HttpClient in an effect, as it creates a default executor and SSL context:\nimport java.net.{InetSocketAddress, ProxySelector}\nimport java.net.http.HttpClient\n\nval client0: IO[Client[IO]] = IO {\n  HttpClient.newBuilder()\n    .version(HttpClient.Version.HTTP_2)\n    .proxy(ProxySelector.of(new InetSocketAddress(\"www-proxy\", 8080)))\n    .build()\n}.map(JdkHttpClient(_))","title":"Custom clients"},{"location":"/index.html#sharing","text":"The client instance contains shared resources such as a connection pool, and should be passed as an argument to code that uses it:\nimport cats.effect._\nimport cats.implicits._\nimport org.http4s._\nimport org.http4s.implicits._\n  \ndef fetchStatus[F[_]](c: Client[F], uri: Uri): F[Status] =\n  c.status(Request[F](Method.GET, uri = uri))\n\nclient\n  .flatMap(c => fetchStatus(c, uri\"https://http4s.org/\"))\n  .attempt\n  .unsafeRunSync()\n// res1: Either[Throwable, Status] = Right(Status(200))\nFailure to share Contrast with this alternate definition of fetchStatus, which would create a new HttpClient instance on every invocation: def fetchStatusInefficiently[F[_]: ConcurrentEffect: ContextShift](uri: Uri): F[Status] =\n  JdkHttpClient.simple[F].flatMap(_.status(Request[F](Method.GET, uri = uri)))","title":"Sharing"},{"location":"/index.html#restricted-headers","text":"The underlying HttpClient may disallow certain request headers like Host or Content-Length to be set directly by the user. Therefore, you can pass a set of ignored headers to JdkHttpClient.apply. By default, the set of restricted headers of OpenJDK 11 is used.\nIn OpenJDK 12+, there are less restricted headers by default, and you can disable the restriction for certain headers by passing -Djdk.httpclient.allowRestrictedHeaders=host,content-length etc. to java.","title":"Restricted headers"},{"location":"/index.html#shutdown","text":"Clients created with this back end do not need to be shut down.","title":"Shutdown"},{"location":"/index.html#further-reading","text":"For more details on the http4s-client, please see the core client documentation.","title":"Further reading"},{"location":"/index.html#websocket-client","text":"This package also contains a functional websocket client. Please note that the API may change in the future.","title":"Websocket client"},{"location":"/index.html#creation","text":"A WSClient is created using an HttpClient as above. It is encouraged to use the same HttpClient to construct a Client[F] and a WSClient[F].\nimport org.http4s.client.jdkhttpclient._\n\nval (http, webSocket) =\n  IO(HttpClient.newHttpClient())\n    .map { httpClient =>\n      (JdkHttpClient[IO](httpClient), JdkWSClient[IO](httpClient))\n    }\n    .unsafeRunSync()\n// http: Client[IO] = org.http4s.client.Client$$anon$1@47cdb22\n// webSocket: WSClient[IO] = org.http4s.client.jdkhttpclient.WSClient$$anon$1@48c8e4a9\nIf you do not need an HTTP client, you can also call JdkWSClient.simple[IO] as above.","title":"Creation"},{"location":"/index.html#overview","text":"We have the following websocket frame hierarchy:\nWSFrame WSControlFrame WSFrame.Close WSFrame.Ping WSFrame.Pong WSDataFrame WSFrame.Text WSFrame.Binary\nThere are two connection modes: “low-level” and “high-level”. Both manage the lifetime of a websocket connection via a Resource. In the low-level mode, you can send and have to receive arbitrary WSFrames. The high-level mode does the following things for you:\nHides the control frames (you can still send Ping and Close frames). Responds to Ping frames with Pongs and echoes Close frames (the received Close frame is exposed as a TryableDeferred). In fact, this currently also the case for the “low-level” mode, but this will change when other websocket backends are added. Groups the data frames by their last attribute.","title":"Overview"},{"location":"/index.html#usage-example","text":"We use the “high-level” connection mode to build a simple websocket app.\nwebSocket\n  .connectHighLevel(WSRequest(uri\"wss://echo.websocket.org\"))\n  .use { conn =>\n    for {\n      // send a single Text frame\n      _ <- conn.send(WSFrame.Text(\"reality\"))\n      // send multiple frames (both Text and Binary are possible)\n      // \"faster\" than individual `send` calls\n      _ <- conn.sendMany(List(\n        WSFrame.Text(\"is often\"),\n        WSFrame.Text(\"disappointing.\")\n      ))\n      received <- conn\n        // a backpressured stream of incoming frames\n        .receiveStream\n        // we do not care about Binary frames (and will never receive any)\n        .collect { case WSFrame.Text(str, _) => str }\n        // send back the modified text\n        .evalTap(str => conn.send(WSFrame.Text(str.toUpperCase)))\n        .take(6)\n        .compile\n        .toList\n    } yield received.mkString(\" \")\n  } // the connection is closed here\n  .unsafeRunSync()\n// res2: String = \"reality is often disappointing. REALITY IS OFTEN DISAPPOINTING.\"\nFor an overview of all options and functions visit the scaladoc.","title":"Usage example"}]}